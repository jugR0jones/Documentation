"use strict";(self.webpackChunkunity=self.webpackChunkunity||[]).push([[7859],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=c(n),d=r,h=u["".concat(l,".").concat(d)]||u[d]||p[d]||o;return n?a.createElement(h,i(i({ref:t},m),{},{components:n})):a.createElement(h,i({ref:t},m))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5251:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return p}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={id:"02-memory-management",title:"Memory Management",tags:["Unity","Design","Patterns","Performance","Memory","Management"]},l=void 0,c={unversionedId:"performance/design-patterns/02-memory-management",id:"performance/design-patterns/02-memory-management",title:"Memory Management",description:"Introduction",source:"@site/docs/performance/01-design-patterns/02-memory-management.md",sourceDirName:"performance/01-design-patterns",slug:"/performance/design-patterns/02-memory-management",permalink:"/docs/performance/design-patterns/02-memory-management",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/performance/01-design-patterns/02-memory-management.md",tags:[{label:"Unity",permalink:"/docs/tags/unity"},{label:"Design",permalink:"/docs/tags/design"},{label:"Patterns",permalink:"/docs/tags/patterns"},{label:"Performance",permalink:"/docs/tags/performance"},{label:"Memory",permalink:"/docs/tags/memory"},{label:"Management",permalink:"/docs/tags/management"}],version:"current",sidebarPosition:2,frontMatter:{id:"02-memory-management",title:"Memory Management",tags:["Unity","Design","Patterns","Performance","Memory","Management"]},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/docs/performance/design-patterns/01-introduction"},next:{title:"References",permalink:"/docs/performance/design-patterns/03-references"}},m={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Memory Organisation",id:"memory-organisation",level:2},{value:"Heap",id:"heap",level:3},{value:"Stack",id:"stack",level:3},{value:"Data Packing",id:"data-packing",level:3},{value:"Garbage Collection Tactics",id:"garbage-collection-tactics",level:2},{value:"Suitable Points To Free Memory",id:"suitable-points-to-free-memory",level:3},{value:"IDispose Interface",id:"idispose-interface",level:3},{value:"Object Pooling",id:"object-pooling",level:2},{value:"Lists vs Arrays vs Linked Lists",id:"lists-vs-arrays-vs-linked-lists",level:2}],u={toc:p};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"The basic philosophy is to minimise garbage collection. Garbage collection results in the CPU running instructions outside of the execution of your scripts. The more this happens, the less time you have each frame to execute your logic."),(0,o.kt)("h2",{id:"memory-organisation"},"Memory Organisation"),(0,o.kt)("h3",{id:"heap"},"Heap"),(0,o.kt)("p",null,"The heap is an area of memory allocated to a class when it is instantiated. Instance variables are stored on the heap."),(0,o.kt)("p",null,"When a class is disposed, the memory on the heap for the class is freed."),(0,o.kt)("h3",{id:"stack"},"Stack"),(0,o.kt)("p",null,'The stack is a region of memory "assigned" to a method, or function when the method is called. This is memory that was allocated when the application starts, so doesn\'t get allocated again while the application is running.'),(0,o.kt)("p",null,"The stack pointer for the CPU points to the stop of the stack."),(0,o.kt)("p",null,"When a method is called, and the method has arguments, the compiler will generate code that may push some register values to the stack before calling, in order to preserve their values, and may push some of the arguments to the method onto the stack as well."),(0,o.kt)("p",null,"When the method returns, the compiler generates code to pop values off the stack. If the method returns a value, this value may be one of the values that are popped off the stack as well."),(0,o.kt)("h3",{id:"data-packing"},"Data Packing"),(0,o.kt)("p",null,"The C# compiler does a pretty good job of organising variables in memory. It is possible however, to take over this responsibility, but its not recommended unless you have good reason."),(0,o.kt)("p",null,"The compiler will generally re-arrange your variables in memory during compilation. This will ensure the data is packed optimally."),(0,o.kt)("p",null,"The CPU access data quicker when the data is aligned to certain values. A 64bit CPU will access data in blocks of 64bits. If our data is aligned to the same 64bit boundaries, the CPU can read 1 64bit value into memory, or 2 32bit values into memory, in one go."),(0,o.kt)("p",null,"If the data spans a 64bit boundary, the CPU will take longer to load the data into memory."),(0,o.kt)("p",null,"When the compiler arranges data, it tries to ensure that data of the same type and size is located next to each other. This way there are no gaps in the memory."),(0,o.kt)("p",null,"If there are gaps, the CPU ends up reading more memory to get to the data. If there are no gaps, the CPU is able to read less memory."),(0,o.kt)("p",null,"This also helps because more data can be stored in the CPU's cache, which means less cache misses, and less trips to slower memory."),(0,o.kt)("h2",{id:"garbage-collection-tactics"},"Garbage Collection Tactics"),(0,o.kt)("h3",{id:"suitable-points-to-free-memory"},"Suitable Points To Free Memory"),(0,o.kt)("h3",{id:"idispose-interface"},"IDispose Interface"),(0,o.kt)("h2",{id:"object-pooling"},"Object Pooling"),(0,o.kt)("h2",{id:"lists-vs-arrays-vs-linked-lists"},"Lists vs Arrays vs Linked Lists"))}d.isMDXComponent=!0}}]);